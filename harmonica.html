<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Harmonica Tabs → Piano Notes + MIDI</title>
    <style>
        body {
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
            margin: 0;
            padding: 24px;
            background: #0b0f14;
            color: #e6eaf0;
        }

        h1 {
            font-size: 20px;
            margin: 0 0 16px;
        }

        .card {
            background: #121824;
            border: 1px solid #1e2838;
            border-radius: 12px;
            padding: 16px;
            max-width: 980px;
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .grid3 {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 12px;
        }

        label {
            font-size: 12px;
            color: #b9c3d0;
            display: block;
            margin-bottom: 6px;
        }

        select,
        input[type="text"],
        input[type="number"],
        textarea {
            width: 100%;
            background: #0e1420;
            color: #e6eaf0;
            border: 1px solid #283246;
            border-radius: 8px;
            padding: 8px 10px;
            font-size: 14px;
        }

        textarea {
            min-height: 140px;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        }

        .row {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        button {
            background: #2662ff;
            color: white;
            border: none;
            border-radius: 10px;
            padding: 10px 14px;
            font-size: 14px;
            cursor: pointer;
        }

        button.secondary {
            background: #22314d;
            color: #d7e1f0;
        }

        .muted {
            color: #9dabbd;
            font-size: 12px;
        }

        .output {
            white-space: pre-wrap;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            background: #0e1420;
            border: 1px solid #283246;
            border-radius: 8px;
            padding: 10px;
            min-height: 120px;
        }

        .warn {
            color: #ffb86c;
        }

        .ok {
            color: #93e6a1;
        }
    </style>
</head>

<body>
    <div class="card">
        <h1>Harmonica Tabs → Piano Notes + MIDI</h1>
        <div class="grid">
            <div>
                <label>Harmonica Type</label>
                <select id="type">
                    <option value="diatonic">Diatonic (10-hole, Richter)</option>
                    <option value="chromatic">Chromatic (12-hole, Solo)</option>
                </select>
            </div>
            <div>
                <label>Harmonica Key</label>
                <select id="key">
                    <option>C</option>
                    <option>C#</option>
                    <option>Db</option>
                    <option>D</option>
                    <option>D#</option>
                    <option>Eb</option>
                    <option>E</option>
                    <option>F</option>
                    <option>F#</option>
                    <option>Gb</option>
                    <option>G</option>
                    <option>G#</option>
                    <option>Ab</option>
                    <option>A</option>
                    <option>A#</option>
                    <option>Bb</option>
                    <option>B</option>
                </select>
            </div>
            <div>
                <label>Tempo (BPM)</label>
                <input id="tempo" type="number" min="20" max="240" value="120" />
            </div>
            <div>
                <label>Beats per Token</label>
                <input id="beats" type="number" min="0.25" step="0.25" value="1" />
            </div>
        </div>

        <div class="grid3" style="margin-top:12px;">
            <div>
                <label>Harmonica Tabs (Harptabs notation)</label>
                <textarea id="tabs"
                    placeholder="Examples:\n+4 -4 -3'' (+3 -4)\nUse '<' for chromatic slide: -4< +5<\nBends: ' or b (e.g., -3', -3'')\nChords: parentheses with tokens inside"></textarea>
            </div>
            <div>
                <label>Piano Notes (space or comma separated)</label>
                <textarea id="pianoInput"
                    placeholder="Example: E4 A4 G4 B4 C5 D5 E5 F5 G5 A5 C6 B5 E6 D6 F#6 F6"></textarea>
            </div>
            <div>
                <label>My Harmonica Tabs (+/- with column 1..16)</label>
                <textarea id="myTabsInput"
                    placeholder="Example: +1 -2 +3 -4 +5 -6 +7 -8 +9 -10 +11 -12 +13 -14 +15 -16"></textarea>
            </div>
        </div>

        <div class="row" style="margin-top:12px;">
            <button id="export" class="secondary" disabled>Export MIDI</button>
            <button id="play" class="secondary">Play</button>
            <button id="stop" class="secondary">Stop</button>
            <span class="muted">Guide: + blow, - draw, ' or b = semitone bend, ( ... ) chords, &lt; = chromatic
                slide-in</span>
        </div>
    </div>

    <script>
        // Signed semitone offsets relative to C harp
        const NOTE_OFFSETS = {
            'C': 0,
            'C#': 1, 'Db': -11,
            'D': 2,
            'D#': 3, 'Eb': -9,
            'E': 4,
            'F': -5,
            'F#': 6, 'Gb': -6,
            'G': 7,
            'G#': 8, 'Ab': -4,
            'A': 9,
            'A#': 10, 'Bb': -2,
            'B': 11
        };
        const PPQN = 480;

        function noteName(midi) {
            const names = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const name = names[midi % 12];
            const octave = Math.floor(midi / 12) - 1;
            return name + octave;
        }

        function diatonicBaseMaps() {
            const blow = [60, 64, 67, 72, 76, 79, 84, 88, 91, 96];
            const draw = [62, 67, 71, 74, 77, 81, 83, 86, 89, 93];
            const drawBendsMax = { 1: 1, 2: 2, 3: 3, 4: 1, 5: 1, 6: 1, 7: 0, 8: 0, 9: 0, 10: 0 };
            const blowBendsMax = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 1, 9: 1, 10: 2 };
            return { blow, draw, drawBendsMax, blowBendsMax };
        }

        function diatonicMapsForKey(keyName) {
            const { blow, draw, drawBendsMax, blowBendsMax } = diatonicBaseMaps();
            const off = NOTE_OFFSETS[keyName] || 0;
            const blowK = blow.map(n => n + off);
            const drawK = draw.map(n => n + off);
            return { blow: blowK, draw: drawK, drawBendsMax, blowBendsMax };
        }

        function chromaticMaps() {
            const blow = [60, 64, 67, 72, 76, 79, 84, 88, 91, 96, 100, 103];
            const draw = [62, 65, 69, 71, 74, 77, 81, 83, 86, 89, 93, 95];
            return { blow, draw };
        }

        function tokenizeTabs(input) {
            const tokens = [];
            let i = 0;
            while (i < input.length) {
                const ch = input[i];
                if (ch === '(') {
                    let j = i + 1, buf = '';
                    while (j < input.length && input[j] !== ')') { buf += input[j++]; }
                    const inner = buf.trim().split(/\s+/).filter(Boolean);
                    tokens.push({ type: 'chord', items: inner });
                    i = j + 1;
                } else if (/\s/.test(ch)) {
                    let delim = '';
                    while (i < input.length && /\s/.test(input[i])) { delim += input[i++]; }
                    tokens.push({ type: 'delimiter', text: delim });
                } else {
                    let buf = '';
                    while (i < input.length && !/[\s()]/.test(input[i])) buf += input[i++];
                    tokens.push({ type: 'single', token: buf });
                }
            }
            return tokens;
        }

        function groupsFromTokens(tokens, mapper) {
            const groups = [];
            let pendingDelim = '';
            for (const t of tokens) {
                if (t.type === 'delimiter') {
                    pendingDelim += t.text;
                } else if (t.type === 'single') {
                    const mid = mapper(t.token);
                    if (mid != null) groups.push({ mids: [mid], delim: pendingDelim });
                    pendingDelim = '';
                } else if (t.type === 'chord') {
                    const mids = [];
                    for (const item of t.items) {
                        const mid = mapper(item);
                        if (mid != null) mids.push(mid);
                    }
                    if (mids.length) groups.push({ mids, delim: pendingDelim });
                    pendingDelim = '';
                }
            }
            if (pendingDelim && groups.length) groups[groups.length - 1].delim += pendingDelim;
            return groups;
        }

        function parseToken(tok) {
            const t = tok.replace(/\s+/g, '');
            const hasSlide = t.includes('<');
            const clean = t.replace('<', '');
            // Accept optional sign; default to '+' (blow) when missing.
            const m = clean.match(/^([+-])?(\d{1,2})([b']{1,3})?$/);
            if (!m) return null;
            const sign = m[1] ? m[1] : '+';
            const hole = parseInt(m[2], 10);
            const bendCount = m[3] ? m[3].replace(/b/g, '').length : 0;
            return { sign, hole, bendCount, hasSlide };
        }

        function toMidiDiatonic(parsed, keyName, warnings) {
            const { blow, draw, drawBendsMax, blowBendsMax } = diatonicMapsForKey(keyName);
            if (parsed.hole < 1 || parsed.hole > 10) { warnings.push('Invalid hole for diatonic: ' + parsed.hole); return null; }
            let base = parsed.sign === '+' ? blow[parsed.hole - 1] : draw[parsed.hole - 1];
            let max = parsed.sign === '+' ? blowBendsMax[parsed.hole] : drawBendsMax[parsed.hole];
            if (parsed.bendCount > max) warnings.push('Bend exceeds hole capability at ' + parsed.sign + parsed.hole + ' (max ' + max + ')');
            const bend = Math.min(parsed.bendCount, max);
            base = base - bend;
            return base;
        }

        function toMidiChromatic(parsed, keyOffset, warnings) {
            const { blow, draw } = chromaticMaps();
            if (parsed.hole < 1 || parsed.hole > 12) { warnings.push('Invalid hole for chromatic: ' + parsed.hole); return null; }
            let base = parsed.sign === '+' ? blow[parsed.hole - 1] : draw[parsed.hole - 1];
            if (parsed.hasSlide) base += 1;
            return base + keyOffset;
        }

        function convertTabsToEvents() {
            const type = document.getElementById('type').value;
            const keyName = document.getElementById('key').value;
            const tabs = document.getElementById('tabs').value || '';
            const tokens = tokenizeTabs(tabs);
            const warnings = [];
            const events = [];
            const beats = parseFloat(document.getElementById('beats').value) || 1;
            const groups = groupsFromTokens(tokens, (tok) => {
                const p = parseToken(tok);
                if (!p) return null;
                return type === 'diatonic'
                    ? toMidiDiatonic(p, keyName, warnings)
                    : toMidiChromatic(p, NOTE_OFFSETS[keyName] ?? 0, warnings);
            });
            for (const g of groups) {
                events.push({ notes: g.mids, beats });
            }
            document.getElementById('export').disabled = events.length === 0;
            return events;
        }

        function vlq(n) {
            const bytes = [];
            let buffer = n & 0x7F;
            while ((n >>= 7)) { buffer <<= 8; buffer |= ((n & 0x7F) | 0x80); }
            while (true) { bytes.push(buffer & 0xFF); if (buffer & 0x80) buffer >>= 8; else break; }
            return bytes;
        }

        function buildMIDI(events, bpm) {
            const tempo = Math.round(60000000 / bpm);
            const header = [0x4D, 0x54, 0x68, 0x64, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x01, 0xE0];
            const track = [];
            track.push(...vlq(0), 0xFF, 0x51, 0x03, (tempo >> 16) & 0xFF, (tempo >> 8) & 0xFF, tempo & 0xFF);
            let ticks = 0;
            for (const ev of events) {
                const durTicks = Math.round(ev.beats * PPQN);
                track.push(...vlq(ticks));
                ticks = 0;
                for (let i = 0; i < ev.notes.length; i++) {
                    const n = ev.notes[i];
                    track.push(0x90, n & 0x7F, 64);
                }
                ticks += durTicks;
                track.push(...vlq(durTicks));
                for (let i = 0; i < ev.notes.length; i++) {
                    const n = ev.notes[i];
                    track.push(0x80, n & 0x7F, 64);
                }
            }
            track.push(...vlq(0), 0xFF, 0x2F, 0x00);
            const length = track.length;
            const trackHeader = [0x4D, 0x54, 0x72, 0x6B, (length >> 24) & 0xFF, (length >> 16) & 0xFF, (length >> 8) & 0xFF, length & 0xFF];
            const bytes = new Uint8Array([...header, ...trackHeader, ...track]);
            return new Blob([bytes], { type: 'audio/midi' });
        }

        document.getElementById('export').addEventListener('click', () => {
            const bpm = parseFloat(document.getElementById('tempo').value) || 120;
            const ev = window.__events || convertTabsToEvents();
            if (!ev || !ev.length) return;
            const blob = buildMIDI(ev, bpm);
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'harmonica.mid';
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
        });

        // Simple WebAudio piano-like playback
        let audioCtx = null;
        let activeNodes = [];
        function midiToFreq(m) { return 440 * Math.pow(2, (m - 69) / 12); }
        function ensureCtx() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
        function scheduleNote(midi, startTime, duration) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();
            osc.type = 'triangle';
            osc.frequency.value = midiToFreq(midi);
            filter.type = 'lowpass';
            filter.frequency.value = 1200;
            filter.Q.value = 0.7;
            const a = 0.005, d = 0.08, s = 0.25, r = Math.min(0.08, duration * 0.4);
            const g = gain.gain;
            g.cancelScheduledValues(startTime);
            g.setValueAtTime(0.0001, startTime);
            g.linearRampToValueAtTime(1.0, startTime + a);
            g.linearRampToValueAtTime(s, startTime + a + d);
            g.setValueAtTime(s, startTime + Math.max(0, duration - r));
            g.linearRampToValueAtTime(0.0001, startTime + duration);
            osc.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination);
            osc.start(startTime);
            osc.stop(startTime + duration + 0.01);
            activeNodes.push({ osc, gain, filter });
        }
        function stopPlayback() {
            try {
                for (const n of activeNodes) { try { n.osc.stop(); } catch (_) { } }
            } finally { activeNodes = []; }
        }
        function playEvents(events, bpm) {
            if (!events || !events.length) return;
            ensureCtx();
            const spb = 60 / (bpm || 120);
            const now = audioCtx.currentTime + 0.05;
            let t = now;
            for (const ev of events) {
                const dur = (ev.beats || 1) * spb;
                for (const n of ev.notes) scheduleNote(n, t, dur);
                t += dur;
            }
        }
        document.getElementById('play').addEventListener('click', () => {
            const bpm = parseFloat(document.getElementById('tempo').value) || 120;
            const ev = window.__events || convertTabsToEvents();
            stopPlayback();
            playEvents(ev, bpm);
        });
        document.getElementById('stop').addEventListener('click', () => {
            stopPlayback();
        });

        // ===== Three-way Converter: mappings and helpers =====
        const MY_HARP_MAP = [
            { col: 1, sign: '+', midi: 64 }, // E4
            { col: 2, sign: '-', midi: 69 }, // A4
            { col: 3, sign: '+', midi: 67 }, // G4
            { col: 4, sign: '-', midi: 71 }, // B4
            { col: 5, sign: '+', midi: 72 }, // C5
            { col: 6, sign: '-', midi: 74 }, // D5
            { col: 7, sign: '+', midi: 76 }, // E5
            { col: 8, sign: '-', midi: 77 }, // F5
            { col: 9, sign: '+', midi: 79 }, // G5
            { col: 10, sign: '-', midi: 81 }, // A5
            { col: 11, sign: '+', midi: 84 }, // C6
            { col: 12, sign: '-', midi: 83 }, // B5
            { col: 13, sign: '+', midi: 88 }, // E6
            { col: 14, sign: '-', midi: 86 }, // D6
            { col: 15, sign: '+', midi: 90 }, // F#6
            { col: 16, sign: '-', midi: 89 }, // F6
        ];
        const MY_HARP_MIDI_TO_TAB = new Map(MY_HARP_MAP.map(x => [x.midi, `${x.sign}${x.col}`]));
        const MY_HARP_COL_TO = new Map(MY_HARP_MAP.map(x => [x.col, x]));

        function parsePianoTokens(input, warnings) {
            const text = (input || '')
                .replace(/[\u266F]/g, '#')   // ♯ -> #
                .replace(/[\u266D]/g, 'b');   // ♭ -> b
            const tokens = [];
            let i = 0;
            while (i < text.length) {
                const ch = text[i];
                if (ch === '(') {
                    let j = i + 1, buf = '';
                    while (j < text.length && text[j] !== ')') { buf += text[j++]; }
                    tokens.push({ type: 'chord', items: buf.trim().split(/\s+/).filter(Boolean) });
                    i = j + 1;
                } else if (/\s/.test(ch)) {
                    let delim = '';
                    while (i < text.length && /\s/.test(text[i])) { delim += text[i++]; }
                    tokens.push({ type: 'delimiter', text: delim });
                } else {
                    let buf = '';
                    while (i < text.length && !/[\s()]/.test(text[i])) buf += text[i++];
                    tokens.push({ type: 'single', token: buf });
                }
            }
            return groupsFromTokens(tokens, (tok) => {
                const m = midiFromNoteName(tok);
                if (m == null) {
                    if (warnings) warnings.push('Unrecognized piano note: ' + tok);
                    return null;
                }
                return m;
            });
        }

        function midiFromNoteName(note) {
            // Accept forms like C4, C#4, Db4
            const m = note.match(/^([A-Ga-g])([#b]?)(\d{1,2})$/);
            if (!m) return null;
            const letter = m[1].toUpperCase();
            const acc = m[2] || '';
            const oct = parseInt(m[3], 10);
            const base = { C: 0, D: 2, E: 4, F: 5, G: 7, A: 9, B: 11 }[letter];
            if (base == null) return null;
            let sem = base + (acc === '#' ? 1 : acc === 'b' ? -1 : 0);
            // normalize into 0..11
            sem = (sem + 12) % 12;
            return 12 * (oct + 1) + sem;
        }

        function midisFromHarptabsString(text, type, keyName, warnings) {
            const tokens = tokenizeTabs(text || '');
            return groupsFromTokens(tokens, (tok) => {
                const p = parseToken(tok);
                if (!p) { warnings.push('Unrecognized token: ' + tok); return null; }
                return type === 'diatonic' ? toMidiDiatonic(p, keyName, warnings) : toMidiChromatic(p, NOTE_OFFSETS[keyName] ?? 0, warnings);
            });
        }

        function midisToPianoString(groups) {
            const parts = [];
            for (const g of groups) {
                const toks = g.mids.map(noteName);
                parts.push(toks.length > 1 ? '(' + toks.join(' ') + ')' : toks[0]);
                if (g.delim) parts.push(g.delim);
            }
            return parts.join('');
        }

        function midisToMyHarpString(groups, warnings) {
            const parts = [];
            for (const g of groups) {
                const tokens = g.mids.map(m => {
                    const tab = MY_HARP_MIDI_TO_TAB.get(m);
                    if (!tab) { warnings.push('Note not on my harmonica: ' + noteName(m)); return '�'; }
                    return tab;
                });
                parts.push(tokens.length > 1 ? '(' + tokens.join(' ') + ')' : tokens[0]);
                if (g.delim) parts.push(g.delim);
            }
            return parts.join('');
        }

        function myHarpStringToMidis(text, warnings) {
            const tokens = [];
            let i = 0;
            while (i < (text || '').length) {
                const ch = text[i];
                if (ch === '(') {
                    let j = i + 1, buf = '';
                    while (j < text.length && text[j] !== ')') { buf += text[j++]; }
                    tokens.push({ type: 'chord', items: buf.trim().split(/\s+/).filter(Boolean) });
                    i = j + 1;
                } else if (/\s/.test(ch)) {
                    let delim = '';
                    while (i < text.length && /\s/.test(text[i])) { delim += text[i++]; }
                    tokens.push({ type: 'delimiter', text: delim });
                } else {
                    let buf = '';
                    while (i < text.length && !/[\s()]/.test(text[i])) buf += text[i++];
                    tokens.push({ type: 'single', token: buf });
                }
            }

            return groupsFromTokens(tokens, (tok) => {
                const m = tok.match(/^([+-])?(\d{1,2})$/);
                if (!m) { warnings.push('Unrecognized my-harp token: ' + tok); return null; }
                const sign = m[1] || '+';
                const col = parseInt(m[2], 10);
                const info = MY_HARP_COL_TO.get(col);
                if (!info) { warnings.push('Invalid column: ' + col); return null; }
                if (sign !== info.sign) warnings.push('Sign mismatch for col ' + col + ' (expected ' + info.sign + ')');
                return info.midi;
            });
        }

        function mapMidiToHarptab(m, type, keyName, warnings) {
            if (type === 'diatonic') {
                const { blow, draw, drawBendsMax, blowBendsMax } = diatonicMapsForKey(keyName);
                const target = m;
                let best = null;
                for (let i = 1; i <= 10; i++) {
                    const b = blow[i - 1];
                    const maxB = blowBendsMax[i];
                    for (let k = 0; k <= maxB; k++) if (b - k === target) best = best && best.k <= k ? best : { token: '+' + i + "'".repeat(k), k };
                    const d = draw[i - 1];
                    const maxD = drawBendsMax[i];
                    for (let k = 0; k <= maxD; k++) if (d - k === target) best = best && best.k <= k ? best : { token: '-' + i + "'".repeat(k), k };
                }
                if (!best) { warnings.push('Unplayable on diatonic: ' + noteName(m)); return '�'; }
                return best.token;
            } else {
                const { blow, draw } = chromaticMaps();
                const target = m - (NOTE_OFFSETS[keyName] ?? 0);
                let best = null;
                for (let i = 1; i <= 12; i++) {
                    const b = blow[i - 1];
                    if (b === target) best = best || { token: '+' + i };
                    if (b + 1 === target) best = best || { token: '+' + i + '<' };
                    const d = draw[i - 1];
                    if (d === target) best = best || { token: '-' + i };
                    if (d + 1 === target) best = best || { token: '-' + i + '<' };
                }
                if (!best) { warnings.push('Unplayable on chromatic: ' + noteName(m)); return '�'; }
                return best.token;
            }
        }

        function midisToHarptabsString(groups, type, keyName, warnings) {
            const parts = [];
            for (const g of groups) {
                const toks = g.mids.map(m => mapMidiToHarptab(m, type, keyName, warnings));
                parts.push(toks.length > 1 ? '(' + toks.join(' ') + ')' : toks[0]);
                if (g.delim) parts.push(g.delim);
            }
            return parts.join('');
        }

        function syncFrom(source) {
            const type = document.getElementById('type').value;
            const keyName = document.getElementById('key').value;
            const warn = [];
            let groups = [];
            if (source === 'harptabs') {
                const ht = document.getElementById('tabs').value;
                groups = midisFromHarptabsString(ht, type, keyName, warn);
            } else if (source === 'piano') {
                const p = document.getElementById('pianoInput').value;
                groups = parsePianoTokens(p, warn);
            } else if (source === 'myharp') {
                const mt = document.getElementById('myTabsInput').value;
                groups = myHarpStringToMidis(mt, warn);
            }
            // Update the other two with preserved delimiters
            const pianoStr = midisToPianoString(groups);
            const myStr = midisToMyHarpString(groups, warn);
            const htStr = midisToHarptabsString(groups, type, keyName, warn);
            const pianoEl = document.getElementById('pianoInput');
            const myEl = document.getElementById('myTabsInput');
            const htEl = document.getElementById('tabs');
            if (source !== 'piano') pianoEl.value = pianoStr;
            if (source !== 'myharp') myEl.value = myStr;
            if (source !== 'harptabs') htEl.value = htStr;
            // Recompute events from current harptabs for MIDI/playback
            window.__events = convertTabsToEvents();
            // Show warnings if any (find first .warn element)
            const warnEl = document.querySelector('.warn');
            if (warnEl) warnEl.textContent = warn.length ? warn.join('\n') : '';
        }

        // Hook up three-way live syncing
        document.getElementById('tabs').addEventListener('input', () => syncFrom('harptabs'));
        document.getElementById('pianoInput').addEventListener('input', () => syncFrom('piano'));
        document.getElementById('myTabsInput').addEventListener('input', () => syncFrom('myharp'));

        // Re-sync when type or key changes
        document.getElementById('type').addEventListener('change', () => {
            const tabs = document.getElementById('tabs').value;
            const piano = document.getElementById('pianoInput').value;
            const myTabs = document.getElementById('myTabsInput').value;
            if (tabs) syncFrom('harptabs');
            else if (piano) syncFrom('piano');
            else if (myTabs) syncFrom('myharp');
        });
        document.getElementById('key').addEventListener('change', () => {
            const tabs = document.getElementById('tabs').value;
            const piano = document.getElementById('pianoInput').value;
            const myTabs = document.getElementById('myTabsInput').value;
            if (tabs) syncFrom('harptabs');
            else if (piano) syncFrom('piano');
            else if (myTabs) syncFrom('myharp');
        });
    </script>
</body>

</html>